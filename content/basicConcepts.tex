% this file is called up by main.tex
% content in this file will be fed into the main document

% ---------------------------------------------------------------------------



\chapter{Basic concepts}
\label{chap:basicConcepts}


\section{A few words about notation}

One focal objective of this report was to collect, review, correct and homogenize all existing information concerning the inner workings of the Monero cryptocurrency. And, at the same time supply all the necessary details to present the material in a constructive and single-threaded manner.

An important instrument to achieve this was to settle for a number of notational conventions. Among others, we have used:

\begin{itemize}
\item lower case letters to denote simple values, integers, strings, bit representations, etc
\item upper case letters to denote curve points and complex constructs
\end{itemize}

For items with a special meaning, we have tried to use as much as possible the same symbols throughout the document. For instance, a curve generator is always denoted by \(G\), its order is \(l\), private/public keys are denoted whenever possible by \(k/K\) respectively, etc.
\\

Beyond that, we have aimed at being {\em conceptual} in our presentation of algorithms and schemes. A reader with a computer science background may feel that we have neglected questions like the bit representation of items, or, in some cases, how to carry out concrete operations.

However, we don’t see this as a loss. A simple object such as an integer or a string can always be represented by a bit string. So-called {\em endianness} is rarely relevant, and is mostly a matter of convention for our algorithms.

Elliptic curve points are normally denoted by pairs \((x, y)\), and can therefore be represented with two integers. However, in the world of cryptography it is common to apply {\em point compression} techniques, which allow representing a point using only the space of one coordinate. For our conceptual approach it is often accessory whether point compression is used or not, but most of the time it is implicitly assumed.

We have also used hash functions freely without specifying any concrete algorithms. In the case of Monero it will typically be a \(\mathit{Keccak}\)\footnote{\label{kekkak_note}The Keccak hashing algorithm forms the basis
for the NIST standard {\em SHA-3}.} 
variant, but if not explicitly mentioned then it is not important to the theory.\footnote{\label{hash_note}A hash function takes in some message $\mathfrak{m}$ of arbitrary length and returns a hash $h$ (or {\em message digest}) of fixed length. Cryptographic hash functions are difficult to reverse, have an interesting feature known as the {\em large avalanche effect} which causes very similar messages to produce very dissimilar hashes, and make it hard to find two messages with the same message digest.}

These hash functions will be applied to integers, strings, curve points, or combinations of these objects. These occurrences should be interpreted as hashes of bit representations, or the concatenation of such representations. Depending on context, the result of a hash will be numeric, a bit string, or even a curve point. Further details in this respect will be given as needed.




\section{Elliptic curve cryptography}
\label{EllipticCurveCryptography}

\subsection{What are elliptic curves}
\label{elliptic_curves_section}


A finite field \(\mathbb{F}_q\), where \(q\) is a prime number greater than 3, is the field formed by the set \(\{0, 1, 2, ..., q-1\}\). Arithmetic operations \((+,  \cdot)\) and the unary operation $(-)$ are calculated \( \pmod q\).\footnote{\label{modulus_note}``calculated \( \pmod q\)" means \( \pmod q\) is performed on any instance of an arithmetic operation between two field elements, or negation of a single field element. For example, given a prime field \(\mathbb{F}_p\) with $p = 29$, $17+20=8$ because $37 \pmod{29} = 8$. Also, $-13 = (-13) \pmod{29} = 16$.

The (positive) modulus is here defined for $a \pmod b = c$ as $a=bx+c$, where $0\leq{c}<{b}$ and $x$ is a signed integer which gets discarded. Imagine a number line. Stand at point $a$. Walk toward zero with each $\text{step} =b$, until you reach an integer $\geq{0}$ and $<b$. That is $c$.}


Typically, elliptic curves are defined as the set of points \((x, y)\) satisfying a {\em Weierstraß} equation for a given $(a,b)$ pair\footnote{\label{notation1}Notation: the phrase $a \in \mathbb{F}$ means $a$ is some element in the field $\mathbb{F}$.}:
\[y^2 = x^3 + a x + b \quad \textrm{where} \quad a, b, x, y \in \mathbb{F}_q \]

However, the cryptocurrency Monero uses a special curve known to offer improved security over other commonly used {\em NIST} curves, as well as cryptographic primitives with excellent performance. The curve used belongs to the category of so-called {\em Twisted Edwards} curves, which are commonly expressed as: 
\[a x^2 + y^2 = 1 + d x^2 y^2 \quad \textrm{where} \quad a, d, x, y \in \mathbb{F}_q \]


In what follows we will prefer this second form. The advantage it offers over the previously mentioned Weierstraß form is that basic cryptographic primitives require less arithmetic operations, resulting in faster cryptographic algorithms. See Bernstein et al. in  \cite{Bernstein2007} for details.
\\

Let \(P_1 = (x_1, y_1)\) and \(P_2 = (x_2, y_2)\) be 2 points belonging to a Twisted Edwards elliptic curve (henceforth known simply as an EC). We can proceed to define the addition operation $P_1 + P_2 = P_3$ in the following manner\footnote{\label{modulus_math_note}$x_3 = (1+d x_1 x_2 y_1 y_2)^{-1} (x_1 y_2+x_1 y_2) \pmod{q}$ can be calculated using the modulus multiplication and addition properties $(A \circ B) \pmod{C} = {[A \pmod {C}] \circ [B \pmod{C}]} \pmod{C}$, and the modular multiplicative inverse. Start inside the parens.

The modular multiplicative inverse is defined as an integer $x$ such that, for $x = a^{-1} \pmod{n}$, $a x \equiv 1 \pmod{n}$ for $0 \leq x < n$ and for $a$ and $n$ relatively prime. The extended Euclidean algorithm finds $x$ like this:
\\ \newline
$Q = 0$; $newQ =1$; $R=n$; $newR =a$ \\
while $newR \ne 0$\\
\indent $quotient = integer(R/newR)$\\
\indent $(Q, newQ) = (newQ, Q - quotient*newQ$)\\
\indent $(R, newR) = (newR, R - quotient*newR$)\\
if $R \leq 1$ then (if $Q < 0$ {\em return $Q + n$} else {\em return Q}) else no solution
\\ \newline
Note on the term {\em congruence}: in the equation $a \equiv b \pmod{c}$, $a$ is congruent to $b \pmod{c}$, which just means $a \pmod{c} = b \pmod{c}$.}\\
\begin{align*}
x_3 & =  \frac{x_1 y_2 + y_1 x_ 2}{1 + d x_1 x_2 y_1 y_2}  \pmod{q} \\
y_3 & =  \frac{y_1 y_2 - a x_1 x_2}{1 - d x_1 x_2 y_1 y_2} \pmod{q} 
\end{align*}

These formulas for addition also apply for point doubling, that is, when  \(P_1 = P_2\). To subtract a point, invert its coordinates $(x,y) \rightarrow (x,-y)$ and do point addition. Whenever a `negative' element $-x$ of $\mathbb{F}_q$ appears in this report, it is really $-x \pmod{q}$.
\\

It turns out that elliptic curves have {\em abelian group} structure\footnote{\label{abelian_note}A concise definition of this notion can be found under \url{https://brilliant.org/wiki/abelian-group/}} under the addition operation described. Each time the operation is performed $P_3$ is a point on the `original' elliptic curve, or in other words all $x_3,y_3 \in \mathbb{F}_q$.

Each point $P$ in EC can generate a subgroup of order (size) $u$ out of some of the other points in EC using multiples of itself. For example, some point $P$’s subgroup might have order 5 and contain the points $(0P, P, 2P, 3P, 4P)$, each of which is in EC. At $5P$ the so-called {\em point-at-infinity} appears, which is like the `zero’ position on an EC and has coordinates $(0, 1)$. 

Conveniently, $0P = 5P$ and $5P + P = P$. This means the subgroup is {\em cyclical}\footnote{\label{cyclical_note}Cyclical subgroups mean, for $P$'s subgroup with order $u$ and any integer $n$, $n P = [n \pmod{u}] P$.}. All $P$ in EC generate a cyclical subgroup. If $P$ generates a subgroup whose order\footnote{\label{find_order_note}To find the order, $u$, of $P$'s subgroup:
\begin{enumerate}
    \item Find $N$ (e.g. use {\em Schoof's algorithm}) 
    \item Find all the divisors of $N$
    \item For every divisor $n$ of $N$, compute $n P$.
    \item The smallest $n$ such that $n P = 0$ is the order $u$ of the subgroup.
\end{enumerate}} is prime then all the included points (except for the point-at-infinity) also generate that subgroup.

Each EC has an order $N$ equal to the total number of points in the curve including the point-at-infinity, and the orders of all subgroups generated by points are divisors of $N$ (by {\em Lagrange’s theorem}). 

ECs selected for cryptography typically have $N = hl$, where $l$ is some sufficiently large prime number (such as 160 bits). One point in the subgroup of size $l$ (note: $h$ is called the {\em cofactor}) is usually selected to be the generator $G$ as a convention. For every other point $P$ in the subgroup there exists an integer $n$ satisfying $P = nG$.\footnote{\label{subgroups_note}Say there is a point $P'$ with order $N$ $(N=h l)$. Any other point in EC can be found with $P_i=n_i P'$. If $P_1=n_1 P'$ has order $l$, any $P_2=n_2 P'$ with order $l$ must be in the same subgroup as $P_1$ because $l P_1=0 = l P_2$, and if $l(n_1 P') \equiv l(n_2 P') \equiv N P=0$, then $n_1$ \& $n_2$ must both be multiples of $h$. In other words, the subgroup formed by multiples of $(h P')$ always contains $P_1$ and $P_2$. Furthermore, $h(n' P')=0$ when $n'$ is a multiple of $l$, and such an $n'$ multiplied by $P'$ can only make $h$ points before $n' = h l$, which cycles back to 0: $h l P' = 0P' = 0$. So, there are only $h$ points in EC where $h P$ will equal 0.
\\ \newline
To find a suitable $G$:
\begin{enumerate}
    \item Find $N$ of EC, choose subgroup order $l$, compute $h=N/l$
    \item Choose a random point $P$ in EC
    \item Compute $G=h P$
    \item If $G=0$ return to step 3, else $G$ generates a subgroup of order $l$
\end{enumerate}}

Calculating the scalar product $nP$ is not difficult\footnote{\label{point_multiplication_note}The scalar product $nP$ is equivalent to $(((P+P)+P)…)$. One basic yet powerful algorithm to shorten the calculation of $nP$ is known as {\em double-and-add}. Let us demonstrate by example. Say $n = 7$, so $nP = P+P+P+P+P+P+P$. Now break this into groups of two. $(P+P) + (P+P) + (P+P) + P$. And again, by groups of two. $[(P+P) + (P+P)] + (P+P) + P$. The total number of $+$ point operations falls from 6 to 4 because $(P+P)$ only needs to be found once.

Double-and-add is implemented by first converting $n$ to binary, then looping through the resultant array to get the sum $Q = nP$. Remember to use the $+$ point operation discussed in Section \ref{elliptic_curves_section}. This algorithm assumes big-endianness:
\\ \newline
$n_{scalar} \rightarrow n_{binary}$; $A = [n_{binary}]$;  $Q=0$, the point-at-infinity; $R=P$\\
for $k = (A_{size} - 1)$...0\\
\indent if A[k] == 1\\
\indent \indent Q += R\\
\indent R += R\\
return Q}, whereas finding $n$ such that $P_1 = n P_2$ is known to be computationally hard. By analogy to modular arithmetic, this problem is often called the {\em discrete logarithm problem} (DLP). In other words, scalar multiplication can be seen as a {\em one-way function}, which paves the way for using elliptic curves for cryptography.

\subsection{Public key cryptography with elliptic curves}
\label{ec:keys}
Public key cryptography algorithms can be devised in a way analogous to modular arithmetic.

Let \(k\) be a randomly selected number satisfying \(1 < k < l\), and call it a {\em private key}. Calculate the corresponding {\em public key} \(K = k G\). 

Due to the {\em discrete logarithm problem} (DLP) we can not easily deduce \(k\) from \(K\) alone. This property allows us to use the values \( (k, K) \) in common public key cryptography algorithms.

\newpage
\subsection{Diffie-Hellman key exchange with elliptic curves}
\label{DH_exchange_section}

A basic {\em Diffie-Hellman} exchange of a shared secret between {\em Alice} and {\em Bob} could take place in the following manner:

\begin{enumerate}
	
	\item Alice and Bob generate their own private/public keys \((k_A, K_A) \quad \textrm{and} \quad (k_B, K_B)\). Both publish or exchange their public keys, and keep the private keys for themselves.
	
	\item Clearly, it holds that \[S = k_A K_B = k_A k_B G = k_B k_A G = k_B K_A\]
	
	 Alice could privately calculate \(S = k_A K_B\), and Bob \(S = k_B K_A\), allowing them to use this single value as a shared secret.
	
\end{enumerate}   

An external observer would not be able to easily calculate the shared secret due to the DLP, which prevents them from finding $k_A$ or $k_B$.


\subsection{DSA signatures with elliptic curves (ECDSA)\footnotemark}
\label{ECDSA_section}

\footnotetext{See \cite{ecdsa} and ANSI X9.62 for details not mentioned in this report.}

Typically, a cryptographic signature is performed on a cryptographic hash of a message rather than the message itself.\footnote{\label{message_hash_note}Signing a message hash instead of a message facilitates messages with varying size.} However, in this report we will loosely use the term {\em message} to refer to the message properly speaking and/or its hash value.

\subsubsection*{Signature}

Assume that Alice has the private/public key pair \((k, K)\). To unequivocally sign an arbitrary message  \(\mathfrak{m}\), she could execute the following steps \cite{Hankerson:2003:GEC:940321}:

\begin{enumerate}
	
	\item Calculate a hash of the message using a cryptographically secure hash function, \(h = \mathcal{H}(\mathfrak{m})\)
	
	\item Let $h'$ be the leftmost (big endianness) L$_l$ bits of $h$, where L$_l$ is the bit length of $l$
	
	\item Generate a random integer \(r\) such that \(1 < r < l\) and compute \(P = (x, y) = r G\). 

       If \(x' = x \pmod{l} = 0\) generate another random integer.
	
	\item Calculate \(s = r^{-1} (h' + x' k) \pmod l\).\footnote{Recall footnote \ref{modulus_math_note} for the method to calculate this.} If \(s = 0\) then go to previous step and repeat
	
	\item The signature is \((x', s)\)
\end{enumerate}


\subsubsection*{Verification}

Any third party who knows the EC domain parameters $D$, the signature $(x’, s)$ and the signing method, $\mathfrak{m}$ and the hash function, and $K$  can verify the signature\footnote{The paper on ECDSA \cite{ecdsa} recommends validating $D$ and $K$ are legitimate before verifying a signature. See \cite{eddsa-irtf} for an overview of $D$.}, which means proving that $s$ was created by the owner of $k$ for the message $\mathfrak{m}$, by calculating

\begin{align*}
  \textrm{check that } & x' \textrm{ and } s \textrm{ are in the interval } [1,q-1] \\
  u_1 & = s^{-1} h' \pmod{l} \\
  u_2 & = s^{-1} x' \pmod{l} \\
  Q   & = u_1 G + u_2 K \textrm{; if $Q = 0$ reject the signature}
\end{align*}

The signature will be valid if and only if the first coordinate of \(Q = (x_Q, y_Q)\) satisfies  
\[x_Q \equiv x' \pmod {l}\]

\subsubsection*{Why it works}

This stems from the fact that
\begin{align*}
Q &= u_1 G + u_2 K \\
  &= s^{-1} h' G + s^{ -1} x' k G \\
  &= s^{-1} (h + x' k) G
\end{align*}

Since \(s = r^{-1} (h' + x' k) \pmod{l} \), it follows\footnote{\label{inverse_rule_note}The modular multiplicative inverse has a rule stating:\\
{\em If $a x \equiv b \pmod{n}$ with $a$ and $n$ relatively prime, the solution to this linear congruence is given by $x = a^{-1} b \pmod{n}$.}\\
Therefore since $l$ is prime, $s = r^{-1} z \pmod{l} \rightarrow s r \equiv z \pmod{l} \rightarrow r \equiv s^{-1}z \pmod{l}$ with $z = (h’ + x’ k)$.
}
that \(r \equiv s^{-1}(h' + x' k) \pmod{l}\), so\footnote{\label{recall1_note}Recalling footnote \ref{cyclical_note}: $n P = n \pmod{u} P$}
\[Q = r G\]

Therefore the owner of $k$ created $s$ for $\mathfrak{m}$: he signed the message.

\section{Curve Ed25519}
\label{Ed25519_section}

Monero uses a particular Twisted Edwards elliptic curve for cryptographic operations, {\em Ed25519}, the {\em birational equivalent}\footnote{\label{birational_note}Without giving further details, birational equivalence can be thought of as an isomorphism that can be expressed using rational terms.} 
of the Montogomery curve {\em Curve25519}.

Both Curve25519 and Ed25519 were released by Bernstein {\em et al.} \cite{Bernstein2008, Bernstein2012, cryptoeprint:2007:286}.

The curve is defined over the prime field \(\mathbb{F}_{2^{255} - 19} \) by means of the following equation:\\
\[ -x^2 + y^2 = 1 - \frac{121665}{121666} x^2 y^2 \]

This curve addresses many concerns raised by the cryptography community. It is well known that {\em NIST}\footnote{\label{NIST_note}National Institute of Standards and Technology, \url{https://www.nist.gov/}} 
standard algorithms have issues. For example, it has recently become clear that the random number generation algorithm {\em PNRG} is flawed and contains a potential backdoor \cite{hales2014nsa}. Seen from a broader perspective, curves endorsed by the NIST are also indirectly endorsed by the NSA, something that the cryptography community sees with suspicion The NSA is notorious for using its power over the NIST to weaken cryptographic algorithms \cite{NSA-NIST}.
\\

Curve Ed25519 is not subject to any patents (see \cite{ECC-patents} for a discussion on this subject), and the team behind it has
developed and adapted basic cryptographic algorithms with efficiency in mind \cite{cryptoeprint:2007:286}. More importantly, it is currently thought to be secure.

Twisted Edwards curves have order expressable as \(N=2^c l\), where \(l\) is a prime number and \(c\) a positive integer. In the case of curve Ed25519, its order is a 76 decimal digit number:
\[2^3 \cdot 7237005577332262213973186563042994240857116359379907606001950938285454250989\]


\subsection{Binary representation}
\label{binary_note}
Elements of \(\mathbb{F}_{2^{255} - 19} \) are 256-bit integers. In other words, they can be represented using 32 bytes. Since each element only requires 255 bits, the most significant bit is always zero.

Consequently, any point in Ed25519 could be expressed using 64 bytes.
By applying {\em point compression} techniques, described here below, however, it is possible to reduce this amount by half, to 32 bytes.

\subsection{Point compression}
\label{point_compression_section}

The Ed25519 curve has the property that its points can be easily compressed, so that representing a point will consume only the space of one coordinate. We will not delve into the mathematics necessary to justify this, but we can give a brief insight into how it works \cite{Bernstein2012}.

This point compression scheme follows from a transformation of the Twisted Edwards curve equation: $x^2 = (1-y^2)/(a-d y^2)$, which indicates there are two possible $x$ values ($+$ or $-$) for each $y$. Field elements $x$ and $y$ are calculated $\pmod{q}$, so there are no actual negative values. However, taking $\pmod{q}$ of $–x$ will change the value between odd and even since $q$ is odd. For example: $-3 \pmod{5} = 2$, $-6 \pmod{9} = 3$. In other words, the field elements $x$ and $–x$ have different odd/even assignments.

If we know $x$ is even, but given its $y$ value the transformed curve equation outputs an odd number (the `positive' x), then we know negating that value will give us the right $x$. One bit can convey this information, and conveniently the $y$ coordinate has an extra bit.

Assume that we want to compress a point \((x, y)\).
We will employ a little-endian representation of integers. Note: $q = 2^{255}-19$ is congruent to $5 \pmod{8}$.

\begin{description}
	
	
	\item[Encoding] We set the most significant bit of $y$ to 0 if $x$ is even, and 1 if it is odd. The resulting value $y’$ will represent the curve point.
	
	\item[Decoding] Retrieve the compressed point $y’$, then copy its most significant bit to the parity bit $b$ before setting it to 0. That will be $y$. \\
	 Let \(u = y^2-1\) and \(v = d y^2  + 1\). \\
	 Compute\footnote{\label{exponent_algorithm_note}Similar to the double-and-add algorithm in footnote \ref{point_multiplication_note}, we could find $a^e \pmod{n}$ like this:
\newline
$e_{scalar} \rightarrow e_{binary}$; $A = [e_{binary}]$; $Q = 1$; $R = a$\\
for $k = (size_A - 1)$…0\\
\indent	if $A[k] == 1$\\
\indent \indent	$Q = Q*R \pmod{n}$\\
\indent	$R = R*R \pmod{n}$\\
return Q

Note: each modular scalar multiplication can be calculated using the algorithm in footnote \ref{point_multiplication_note} by replacing EC point addition with modular addition.

This also provides an intuitive but moderately slower alternative to the extended Euclidean algorithm for the modular multiplicative inverse (footnote \ref{modulus_math_note}). When $n$ is a prime number we can use {\em Fermats’ little theorem}: 
\center $a^{n-1} \equiv 1 \pmod{n} 	\rightarrow 	a^{-1} \equiv a^{n-2} \pmod{n}$} \(x = u v^3 (u v^7)^{(q-5)/8}\)
	 \begin{enumerate}
	 \item If \(v x^2 = u \pmod q\) then keep \(x\)
	 \item Else set \(x = x 2^{(q-1)/4} \pmod q\)
	 \item Using the parity bit \(b\) retrieved in the first step, if $b \ne$ the least significant bit of $x$ then return \(q - x\) (the same as $-x \pmod{q}$), otherwise return \(x\)
	 \end{enumerate}	
	
\end{description}

\subsection{EdDSA signature algorithm}
\label{EdDSA_section}

Bernstein and his team have developed a number of basic algorithms based on curve Ed25519.\footnote{\label{group_ops_twisted_edwards_note}See \cite{cryptoeprint:2007:286} for efficient group operations in Twisted Edwards EC (ie point addition, doubling, mixed addition, etc).}
For illustration purposes we will describe a highly optimized and secure alternative to the ECDSA signature scheme which, according to the authors, allows producing over 100 000 signatures per second using a commodity Intel Xeon processor \cite{Bernstein2012}. The algorithm can also be found described in Internet RFC8032 \cite{rfc8032}.

Among other things, instead of generating random integers every time, it uses a hash value derived from the private key of the signer and the message itself. This circumvents security flaws related to the implementation of random number generators. Also, another goal of the algorithm is to avoid accessing secret or unpredictable memory locations to prevent so-called {\em cache timing attacks}.

We provide here an outline of the steps performed by the algorithm for illustration purposes only. A complete description and sample implementation in the Python language can be found in \cite{rfc8032}. 

\newpage
\subsubsection{Signature}

\begin{enumerate}
	
	\item Let \(h_k\) be a hash \(\mathcal{H}(k)\) of the signer's private key \(k\). 
	Compute \(r\) as a hash \(r = \mathcal{H}(h_k,  \mathfrak{m})\)  of the hashed private key and message.
	
	\item Calculate \(R = r G\) and \(s = (r + \mathcal{H}(R, K,  \mathfrak{m}) \cdot k)) \)
	
	\item the signature is the pair \((R, s)\)
	
	
\end{enumerate}



\subsubsection{Verification}
Verification is performed as follows

\begin{enumerate}
	
	\item Compute \(h = \mathcal{H}(R,  K,  \mathfrak{m}) \)
	
	\item If the equality \(2^c s G = 2^c R + 2^c h K \) holds then the signature is valid\footnote{\label{2cprefix_note}The $2^c$ term comes from Bernstein et al.’s general form of the EdDSA algorithm \cite{cryptoeprint:2007:286}. According to that paper, though it isn’t required for adequate verification, removing $2^c$ provides stronger equations.}
	
\end{enumerate}


\subsubsection{Why it works}

\[ 2^c s G = 2^c ( (r + \mathcal{H}(R, K,  \mathfrak{m}) \cdot k) \cdot G = 2^c R + 2^c \mathcal{H}(R, K,  \mathfrak{m}) \cdot K )\]



\subsubsection{Binary representation}

By default, an EdDSA signature would need \(64 + 32 \) bytes to be represented.
However, RFC8032 assumes that point \(R\) is compressed, which reduces space requirements to only \(32 + 32\) bytes.